# OHR
Optical Handwriting Recognition. Written entirely from scratch, this program uses a series of image manipulation techniques and Neural networks to recognise handwritten letters.
## About this project
My most enjoyable project to date is my optical character recognition project. When I embarked on this project I knew very little about the fundamentals of computer vision and machine learning. In a bid to learn more about these fields I set out to implement the entire project from scratch, without the aid of external libraries.

The system was implemented in Java and the UI in JavaFX. I first started with the core functionality, which would be the method of character classification. I implemented a single layered neural network where each neuron would be responsible for classifying a particular character, each neuron took nxn input of pixels. Each neuron's weightings was carefully tuned through the process of backward propagation which would take a set of training data and adjust the weightings based on that.

In order to isolate each individual character for recognition off the page I devised my own processing pipeline which would take in a page of characters and convert in to plain text. The first step of the process was to blurring and thresholding, each character needed to be converted from colour to a 1-bit representation which can be inserted into each neuron in the network. The blur would help eliminate any outliers and the thresholding would isolate the exact colour of scanned handwriting and convert it to black. The second step was to isolate and crop the exact locations of each pixel formation, using a custom recursive search algorithm I would take every attached formation and each would be passed on to the next step. The third step was determining the ordering of the characters so when classified, it could be properly represented in plain text. The fourth step was passing in each pixel formation into the network for classification. Each neuron would calculate a probability value based on the summation of its weightings and each input value, this was then passed through a logistical sigmoid function (activation function) to normalise the values. Each neuron (A-Z) would present a probability value and the highest of them would be chosen.

This project relied on the use of unit testing to ensure proper functionality. I took this a step further and employed the used of test driven development (TDD) to better direct my project, I found that this ensured that I was keeping true to my original objectives to eliminate scope creep. In every project I like to conform to the S.O.L.I.D principles, which should help keep my code clean and modular. However, in practice error happen, TDD helped me spot changes that would potentially break the build.
